1. handler & implement组合（和proxy是一个套路）  ----->
这种方式可以大大降低编译的依赖性，在该类是一个经常被修改的情况下可以使用。
实现原理就是handler中有一个implement的指针，然后每次的实现都是由这个实例中的具体函数来做。
可以把implement先抽象成一个基类提供泛型特点来处理所有的潜在implement，不过最好不要搞这套（自己的C++编程原则）

2.提供一个统一个管理类（全局单例），然后对于每个对象内部实现一个方法（从抽象基类中继承这个方法），对所有的对象进行管理。<可以用这种方法管理对象的生命周期>！
注意的一个点是管理类控制的是什么，以及需要控制的力度，有时候我们可以控制对象的某个point，只在这个point到达某个点的时候又对象自己free.(由管理类触发，或自己触发)。
  《小小骑士团》的大部分代码都是一个管理类组织其下的对象进行操作，最后提供一个全局的实例来供调用者调用<单例也是可以选择的实现>。

3.依赖继承的接口编程， 编写一个抽象接口类，然后让实现类实现。
这种设计的好处就是可以通过泛型来在对外上提供 AbstractClass *data;
data = new xxxConcreateClass();  清晰明了。

4.
