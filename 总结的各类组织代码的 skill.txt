1. handler & implement组合（和proxy是一个套路）  ----->
这种方式可以大大降低编译的依赖性，在该类是一个经常被修改的情况下可以使用。
实现原理就是handler中有一个implement的指针，然后每次的实现都是由这个实例中的具体函数来做。
可以把implement先抽象成一个基类提供泛型特点来处理所有的潜在implement，不过最好不要搞这套（自己的C++编程原则）

2.提供一个统一个管理类（全局单例），然后对于每个对象内部实现一个方法（从抽象基类中继承这个方法），对所有的对象进行管理。<可以用这种方法管理对象的生命周期>！
注意的一个点是管理类控制的是什么，以及需要控制的力度，有时候我们可以控制对象的某个point，只在这个point到达某个点的时候又对象自己free.(由管理类触发，或自己触发)。
  《小小骑士团》的大部分代码都是一个管理类组织其下的对象进行操作，最后提供一个全局的实例来供调用者调用<单例也是可以选择的实现>。

3.依赖继承的接口编程， 编写一个抽象接口类，然后让实现类实现。
这种设计的好处就是可以通过泛型来在对外上提供 AbstractClass *data;
data = new xxxConcreateClass();  清晰明了。

4.“无锁”数据结构的一些设计思路： 除了用编译器级别的CAS技巧意外，
可以用索引、数据分离的方式只对索引加锁（这样粒度小加锁块），然后再根据索引进行数据的并发写，这里要维护好索引与数据的对应关系（加锁保护），最后需要同步数据的位置
__sync_compare_and_swap(data, index, index+1);
主要的思路就是分离加锁的粒度使得它越小越好。

5.分开编写模块，然后集成到一个类中，通过组合的方式，在该类的update中更新所有的数据的状态已经他们需要进行的操作。（源自cocos2d-x开发中一个场景内动作的实现思路）
也可以通过一个主循环，然后由个子管理系统提供全局变量或者单例给主循环调用update更新其下所有状态。（就是再套一层）

6.面向接口编程，将一些公共的功能，比如人物移动（前端开发）的功能抽象成一个接口，然后各种移动继承它。最后继承到一个实体对象中完成操作。抽象成非常抽象的接口可以是简单的一个controller，然后里面有一个控制对象。《这样会不会使得继承链变得很长？   不一定是好的设计吧？》
