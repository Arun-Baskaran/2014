1. handler & implement组合（和proxy是一个套路）  ----->
这种方式可以大大降低编译的依赖性，在该类是一个经常被修改的情况下可以使用。
实现原理就是handler中有一个implement的指针，然后每次的实现都是由这个实例中的具体函数来做。
可以把implement先抽象成一个基类提供泛型特点来处理所有的潜在implement，不过最好不要搞这套（自己的C++编程原则）

2.提供一个统一个管理类（全局单例），然后对于每个对象内部实现一个方法（从抽象基类中继承这个方法），对所有的对象进行管理。<可以用这种方法管理对象的生命周期>！
注意的一个点是管理类控制的是什么，以及需要控制的力度，有时候我们可以控制对象的某个point，只在这个point到达某个点的时候又对象自己free.(由管理类触发，或自己触发)。
  《小小骑士团》的大部分代码都是一个管理类组织其下的对象进行操作，最后提供一个全局的实例来供调用者调用<单例也是可以选择的实现>。

3.依赖继承的接口编程， 编写一个抽象接口类，然后让实现类实现。
这种设计的好处就是可以通过泛型来在对外上提供 AbstractClass *data;
data = new xxxConcreateClass();  清晰明了。

4.“无锁”数据结构的一些设计思路： 除了用编译器级别的CAS技巧意外，
可以用索引、数据分离的方式只对索引加锁（这样粒度小加锁块），然后再根据索引进行数据的并发写，这里要维护好索引与数据的对应关系（加锁保护），最后需要同步数据的位置
__sync_compare_and_swap(data, index, index+1);
主要的思路就是分离加锁的粒度使得它越小越好。

5.分开编写模块，然后集成到一个类中，通过组合的方式，在该类的update中更新所有的数据的状态已经他们需要进行的操作。（源自cocos2d-x开发中一个场景内动作的实现思路）
也可以通过一个主循环，然后由个子管理系统提供全局变量或者单例给主循环调用update更新其下所有状态。（就是再套一层）

6.面向接口编程，将一些公共的功能，比如人物移动（前端开发）的功能抽象成一个接口，然后各种移动继承它。最后集成到一个实体对象中完成操作。抽象成非常抽象的接口可以是简单的一个controller，然后里面有一个控制对象。《这样会不会使得继承链变得很长？ 不一定是好的设计吧？》 

7.Loki的小对象分配器设计中的多层模型 ----->需要注意的是最底层的开销必须尽量的降到最低，以为在高层使用的时候，最底层的组件将会形成滚雪球效应。
当引入多线程模型的时候，我们不应该在一开始设计的时候就考虑加入多线程机制，那将使得程序设计非常的复杂。只要独立出多线程模型，并在最后的接口层封装集合多线程模型就可以达到多线程的效果。
----->一点启示：多线程的模型我们应该放到哪里，取决于我们怎么样我们的设计。我们如果再接口层使用，则只需要封装接口层使得它具备多线程即可（也许这样会使得锁粒度变得很大）


8.将多种特性分开实现，并通过泛型继承来使得A类拥有这种特性。比如clonenable,threadpolicy特性，A通过继承clonenable<A>就可以直接使用clonenable的特性了。

9.或者也可以像smart_pointer那样在对象的外面再包装一层，来抽象出更高级的东西。有点装饰器的味道。














/*
 *
 *	C语言写法！！！
 *
 *
 */
1.通过内存截断来向上转型，不过必须是child结构中的第一个字段是father结构才行。 （通过这样就可以完成对于多态的模拟，以统一的接口进行操作<面向接口编程>，最后实际操作的时候再转回来。）



